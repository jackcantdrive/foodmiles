<!DOCTYPE html>
<html>
<head>
    <title>Paper Detection</title>
    <script async src="./opencv-4.5.5.js"></script>
    <!-- <script async src="https://docs.opencv.org/4.5.5/opencv.js"></script> -->
</head>
<body>
    <h1>Paper Detection</h1>
    <input type="file" id="fileInput" accept="image/*">

    <img id='image' src="IMG_8409-2-copy.jpg"/>
    <!-- <video id="webcam" width="640" height="480" autoplay></video> -->
    <video id="webcam" src='IMG_8416.mp4' autoplay></video>

    <canvas id="canvasOutput"></canvas>

    <script>
        let img = new Image();
        img.onload = function () {
            scan();
        }

        const scan = () => {
            let canvas = document.createElement('canvas');
            let context = canvas.getContext('2d');
            // canvas.width = img.width;
            // canvas.height = img.height;
            // context.drawImage(img, 0, 0);

            const max_width = 100;
            const width = Math.min(max_width, img.width);
            const scale = img.width / width;
            canvas.width = width;
            canvas.height = Math.floor(img.height / scale);
            context.drawImage(img, 0, 0, canvas.width, canvas.height);


            let src = cv.imread(canvas);
            let dst = new cv.Mat();
            const st = performance.now();
            // Convert to grayscale
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            // Gaussian blur
            cv.GaussianBlur(src, src, new cv.Size(15, 15), 0, 0, cv.BORDER_DEFAULT);
            // Canny edge detection
            // cv.Canny(src, dst, 75, 200);
            cv.Canny(src, dst, 10, 14);

            // Find contours
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            // cv.findContours(dst, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_NONE);

            // // Find the largest contour, assuming it's the paper
            // let largestContour = contours.get(0);
            // for (let i = 1; i < contours.size(); ++i) {
            //     if (cv.contourArea(contours.get(i)) > cv.contourArea(largestContour)) {
            //         largestContour = contours.get(i);
            //     }
            // }

            // // Approximate the contour to a polygon
            // let approx = new cv.Mat();
            // cv.approxPolyDP(largestContour, approx, 0.02 * cv.arcLength(largestContour, true), true);

            // // Draw the polygon on the original image
            // let vertices = [];
            // for (let i = 0; i < approx.rows; ++i) {
            //     vertices.push({x: approx.data32S[i*2], y: approx.data32S[i*2 + 1]});
            // }
            // src = cv.imread(canvas);
            // for (let i = 0; i < vertices.length; i++) {
            //     let pt1 = new cv.Point(vertices[i].x, vertices[i].y);
            //     let pt2 = new cv.Point(vertices[(i + 1) % vertices.length].x, vertices[(i + 1) % vertices.length].y);
            //     cv.line(src, pt1, pt2, [255, 0, 0, 255], 4);
            //     // cv.line(src, pt1, pt2, [0, 255, 255, 255], 4);
            //     debugger
            // }

            const contoursByArea = [];
            for (let i = 0; i < contours.size(); ++i) {
                contoursByArea.push({contour: contours.get(i), area: cv.contourArea(contours.get(i))});
            }
            contoursByArea.sort((a, b) => b.area - a.area);

            // Find the largest contour, assuming it's the paper
            const largestContour = contoursByArea[0].contour;
            src = cv.imread(canvas);

            // debugger;
            for (let i = 0; i < contoursByArea.length && i < 4; i++) {
                const contour = contoursByArea[i].contour;
                console.log(cv.contourArea(contour));
                // Approximate the contour to a polygon
                let approx = new cv.Mat();
                cv.approxPolyDP(contour, approx, 0.02 * cv.arcLength(contour, true), true);

                // Draw the polygon on the original image
                let vertices = [];
                for (let i = 0; i < approx.rows; ++i) {
                    vertices.push({x: approx.data32S[i*2], y: approx.data32S[i*2 + 1]});
                }

                let color;
                if (i === 0) {
                    color = [255, 0, 0, 255];
                } else {
                    color = [0, 0, 255, 255];
                }

                // src = cv.imread(canvas);
                for (let i = 0; i < vertices.length; i++) {
                    let pt1 = new cv.Point(vertices[i].x, vertices[i].y);
                    let pt2 = new cv.Point(vertices[(i + 1) % vertices.length].x, vertices[(i + 1) % vertices.length].y);
                    // cv.line(src, pt1, pt2, [0, 0, 255, 255], 4);
                    cv.line(src, pt1, pt2, color, 4);
                }
                contour.delete();
                approx.delete();
            }

            cv.imshow('canvasOutput', src);

            // Clean up
            src.delete();
            dst.delete();
            contours.delete();
            hierarchy.delete();
            // largestContour.delete();
            // approx.delete();
            console.log(performance.now() - st);
        };
        // img.src = event.target.result;


        function waitForOpenCV(callback) {
            if (typeof cv !== 'undefined' && typeof cv.Mat === 'function') {
                callback();
            } else {
                setTimeout(function() {
                    waitForOpenCV(callback);
                }, 100);
            }
        }

        const webcamScan = () => {
            requestAnimationFrame(webcamScan)
            // render webcam image to canvas
            const webcam = document.getElementById('webcam');
            const webcamCanvas = document.createElement('canvas');
            webcamCanvas.width = webcam.videoWidth;
            webcamCanvas.height = webcam.videoHeight;
            const webcamCtx = webcamCanvas.getContext('2d');
            webcamCtx.drawImage(webcam, 0, 0, webcamCanvas.width, webcamCanvas.height);

            // const targetWidth = 1000;
            // const scale = targetWidth / webcam.videoWidth;
            // webcamCanvas.width = targetWidth;
            // webcamCanvas.height = webcam.videoHeight * scale;
            // const webcamCtx = webcamCanvas.getContext('2d');
            // webcamCtx.drawImage(webcam, 0, 0, webcamCanvas.width, webcamCanvas.height);


            img = webcamCanvas;
            scan();
        }

        waitForOpenCV(() => {

            // img.src = image.src;

            // Get the video element
            // const video = document.getElementById('webcam');

            // // const button = document.createElement('button');
            // // button.onclick = () => {
            // // Check if the browser supports getUserMedia
            // if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            //     // Request access to the webcam
            //     navigator.mediaDevices.getUserMedia({ video: true })
            //         .then(function(stream) {
            //             // Assign the stream to the video element's srcObject
            //             video.srcObject = stream;
            //         })
            //         .catch(function(error) {
            //             console.error("Error accessing the webcam: ", error);
            //         });
            // } else {
            //     console.error("getUserMedia not supported by this browser.");
            // }

            webcamScan();
            // }
            // button.textContent = 'webcam';
            // document.body.append(button);

            
        });
    </script>
</body>
</html>
