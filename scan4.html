<!DOCTYPE html>
<html>
<head>
    <title>Paper Detection</title>
    <script async src="./opencv-4.5.5.js"></script>
    <script src="./perspective.min.js"></script>
    <!-- <script async src="https://docs.opencv.org/4.5.5/opencv.js"></script> -->
    <style>
        #arCanvas {
            height: 50vh;
        }
    </style>
</head>
<body>
    <h1>Paper Detection</h1>
    <input type="file" id="fileInput" accept="image/*">
    <!-- <img id="modifiedMenu" src="IMG_8418-perspective-crop.png"/> -->
    <img id="modifiedMenu" src="test-image.png"/>
    <img id='image' src="IMG_8409-2-copy.jpg"/>
    <!-- <video id="webcam" width="640" height="480" autoplay></video> -->
    <!-- <video id="webcam" src='IMG_8416.mp4' controls autoplay muted></video> -->
    <video id="webcam" src='IMG_8417.mp4' controls autoplay muted></video>

    <canvas id="canvasOutput"></canvas>
    <canvas id="arCanvas"></canvas>

    <script>
        let img = new Image();
        img.onload = function () {
            scan();
        }

        let prevFrameVertices = undefined;
        // let paperDecay = 0;
        let paperDecay2 = [];

        const scan = () => {
            paperDecay2.unshift(0);
            if (paperDecay2.length > 30) {
                paperDecay2.pop();
            }
            let canvas = document.createElement('canvas');
            let context = canvas.getContext('2d');
            // canvas.width = img.width;
            // canvas.height = img.height;
            // context.drawImage(img, 0, 0);

            const max_width = 100;
            const width = Math.min(max_width, img.width);
            const scale = img.width / width;
            canvas.width = width;
            canvas.height = Math.floor(img.height / scale);
            context.drawImage(img, 0, 0, canvas.width, canvas.height);


            let src = cv.imread(canvas);
            let dst = new cv.Mat();
            const st = performance.now();
            // Convert to grayscale
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            // Gaussian blur
            cv.GaussianBlur(src, src, new cv.Size(15, 15), 0, 0, cv.BORDER_DEFAULT);
            // Canny edge detection
            // cv.Canny(src, dst, 75, 200);
            cv.Canny(src, dst, 10, 14);

            // Find contours
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            // cv.findContours(dst, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_NONE);

            // // Find the largest contour, assuming it's the paper
            // let largestContour = contours.get(0);
            // for (let i = 1; i < contours.size(); ++i) {
            //     if (cv.contourArea(contours.get(i)) > cv.contourArea(largestContour)) {
            //         largestContour = contours.get(i);
            //     }
            // }

            // // Approximate the contour to a polygon
            // let approx = new cv.Mat();
            // cv.approxPolyDP(largestContour, approx, 0.02 * cv.arcLength(largestContour, true), true);

            // // Draw the polygon on the original image
            // let vertices = [];
            // for (let i = 0; i < approx.rows; ++i) {
            //     vertices.push({x: approx.data32S[i*2], y: approx.data32S[i*2 + 1]});
            // }
            // src = cv.imread(canvas);
            // for (let i = 0; i < vertices.length; i++) {
            //     let pt1 = new cv.Point(vertices[i].x, vertices[i].y);
            //     let pt2 = new cv.Point(vertices[(i + 1) % vertices.length].x, vertices[(i + 1) % vertices.length].y);
            //     cv.line(src, pt1, pt2, [255, 0, 0, 255], 4);
            //     // cv.line(src, pt1, pt2, [0, 255, 255, 255], 4);
            //     debugger
            // }

            const contoursByArea = [];
            for (let i = 0; i < contours.size(); ++i) {
                contoursByArea.push({contour: contours.get(i), area: cv.contourArea(contours.get(i))});
            }
            contoursByArea.sort((a, b) => b.area - a.area);

            // Find the largest contour, assuming it's the paper
            const largestContour = contoursByArea[0].contour;
            src = cv.imread(canvas);

            // debugger;
            for (let i = 0; i < contoursByArea.length && i < 4; i++) {
                const contour = contoursByArea[i].contour;
                // console.log(cv.contourArea(contour));
                // Approximate the contour to a polygon
                let approx = new cv.Mat();
                cv.approxPolyDP(contour, approx, 0.02 * cv.arcLength(contour, true), true);

                // Draw the polygon on the original image
                let vertices = [];
                for (let i = 0; i < approx.rows; ++i) {
                    vertices.push({x: approx.data32S[i*2], y: approx.data32S[i*2 + 1]});
                }

                // let color;
                // if (i === 0) {
                //     color = [255, 0, 0, 255];
                // } else {
                //     // color = [0, 0, 255, 255];
                //     color = [0, contoursByArea[i].area * 40, 255, 255];
                // }
                let color = [0, contoursByArea[i].area * 40, 255, 255];

                if (vertices.length !== 4 || contoursByArea[i].area < 3) continue;


                // src = cv.imread(canvas);
                for (let i = 0; i < vertices.length; i++) {
                    let pt1 = new cv.Point(vertices[i].x, vertices[i].y);
                    let pt2 = new cv.Point(vertices[(i + 1) % vertices.length].x, vertices[(i + 1) % vertices.length].y);
                    // cv.line(src, pt1, pt2, [0, 0, 255, 255], 4);
                    cv.line(src, pt1, pt2, color, 4);
                }

                if (i === 0) {
                    // console.log(vertices)
                    const verticesScaled = vertices.map(v => ({x: v.x / width, y: v.y / width}));

                    if (prevFrameVertices) {
                        // const prevFrameVerticesSorted = prevFrameVertices.sort((a, b) => a.x - b.x);
                        // const verticesSorted = vertices.sort((a, b) => a.x - b.x);

                        const prevFrameVerticesSorted = prevFrameVertices;
                        // const verticesSorted = vertices;

                        // debugger
                        // note: these labels (eg top left) are probably wrong
                        const topLeft = verticesScaled[0];
                        const topRight = verticesScaled[1];
                        const bottomRight = verticesScaled[2];
                        const bottomLeft = verticesScaled[3];

                        const topLeftPrev = prevFrameVerticesSorted[0];
                        const topRightPrev = prevFrameVerticesSorted[1];
                        const bottomRightPrev = prevFrameVerticesSorted[2];
                        const bottomLeftPrev = prevFrameVerticesSorted[3];

                        const topLeftDiff = Math.abs(topLeft.x - topLeftPrev.x) + Math.abs(topLeft.y - topLeftPrev.y);
                        const topRightDiff = Math.abs(topRight.x - topRightPrev.x) + Math.abs(topRight.y - topRightPrev.y);
                        const bottomRightDiff = Math.abs(bottomRight.x - bottomRightPrev.x) + Math.abs(bottomRight.y - bottomRightPrev.y);
                        const bottomLeftDiff = Math.abs(bottomLeft.x - bottomLeftPrev.x) + Math.abs(bottomLeft.y - bottomLeftPrev.y);
                        // debugger

                        const diffThreshold = 0.1;
                        if (topLeftDiff < diffThreshold && topRightDiff < diffThreshold && bottomRightDiff < diffThreshold && bottomLeftDiff < diffThreshold) {
                            // console.log('Paper detected');
                            // paperDecay += 0.3;
                            paperDecay2[0] = 1;
                        }
                    }

                    // prevFrameVertices = vertices;
                    prevFrameVertices = verticesScaled;
                }

                contour.delete();
                approx.delete();
            }

            cv.imshow('canvasOutput', src);

            updateARCanvas();

            // Clean up
            src.delete();
            dst.delete();
            contours.delete();
            hierarchy.delete();
            // largestContour.delete();
            // approx.delete();
            // console.log(performance.now() - st);
        };
        // img.src = event.target.result;

        let updateARCanvasLastCalled = 0;
        let paperVertices = undefined;
        const updateARCanvas = () => {
            // console.log(';kljhg')

            // paperDecay *= 0.5**(1/60);

            // const now = performance.now();
            // const delta = now - updateARCanvasLastCalled;
            // paperDecay -= delta / 1000 * 10;
            // paperDecay *= 0.5**(delta / 1000);
            // paperDecay = Math.max(0, paperDecay);
            // updateARCanvasLastCalled = now;

            const range = Array(paperDecay2.length).fill().map((_, i) => i);
            const weightsUnnormalized = range.map(i => Math.E**(-i/10));
            const sum = weightsUnnormalized.reduce((a, b) => a + b, 0);
            const weights = weightsUnnormalized.map(w => w / sum);
            const weightedSum = paperDecay2.reduce((a, b, i) => a + b * weights[i], 0);
            console.log(weightedSum)

            const paperDecay = weightedSum;

            console.log(paperDecay);
            const arCanvas = document.getElementById('arCanvas');
            const arContext = arCanvas.getContext('2d');
            arCanvas.width = webcam.videoWidth;
            arCanvas.height = webcam.videoHeight;
            arContext.drawImage(webcam, 0, 0, arCanvas.width, arCanvas.height);

            if (paperDecay > 0) {
                // arContext.fillStyle = 'rgba(0, 255, 0, 0.5)';
                arContext.fillStyle = `rgba(0, 255, 0, ${Math.min(0.5, paperDecay)})`;
                arContext.fillRect(0, 0, arCanvas.width, arCanvas.height);

                paperVertices = prevFrameVertices;

                if (paperVertices) {
                    // arContext.fillStyle = 'rgba(255, 0, 0, 0.5)';
                    arContext.fillStyle = `rgba(255, 0, 0, ${Math.min(0.5, paperDecay)})`;
                    arContext.beginPath();
                    arContext.moveTo(paperVertices[0].x * arCanvas.width, paperVertices[0].y * arCanvas.width);
                    for (let i = 1; i < paperVertices.length; i++) {
                        arContext.lineTo(paperVertices[i].x * arCanvas.width, paperVertices[i].y * arCanvas.width);
                    }
                    arContext.closePath();
                    arContext.fill();

                    // arContext.clearRect(0, 0, arCanvas.width, arCanvas.height);
                    // arContext.fillStyle = '#0f0';

                    // const startX = 100, startY = 100;
                    // const endX = 500, endY = 100;
                    // const bottomX = 500, bottomY = 300;
                    // const topX = 100, topY = 300;

                    // Draw the image with perspective transformation
                    arContext.save();
                    // arContext.beginPath();
                    // arContext.moveTo(startX, startY);
                    // arContext.lineTo(endX, endY);
                    // arContext.lineTo(bottomX, bottomY);
                    // arContext.lineTo(topX, topY);
                    // arContext.closePath();
                    // arContext.clip();

                    // // Transform to apply perspective
                    // arContext.transform(
                    //     endX - startX, endY - startY,
                    //     bottomX - startX, bottomY - startY,
                    //     startX, startY
                    // );

                    // // Draw the image
                    // // arContext.drawImage(modifiedMenu, 0, 0, modifiedMenu.width, modifiedMenu.height, startX, startY, endX - startX, bottomY - startY);
                    // arContext.fillRect(startX, startY, endX - startX, bottomY - startY);
                    // // debugger


                    const srcPoints = [
                        { x: 0, y: 0 },
                        { x: modifiedMenu.width, y: 0 },
                        { x: modifiedMenu.width, y: modifiedMenu.height },
                        { x: 0, y: modifiedMenu.height }
                    ];

                    // const dstPoints = [
                    //     { x: 50, y: 50 },
                    //     { x: 250, y: 50 },
                    //     { x: 200, y: 200 },
                    //     { x: 0, y: 200 }
                    // ];
                    const dstPoints = prevFrameVertices.map(p => ({x: p.x * arCanvas.width, y: p.y * arCanvas.width}));

                    var p = new Perspective(arContext, modifiedMenu);
                    // p.draw([
                    //         [30, 30],
                    //         [modifiedMenu.width - 50, 50],
                    //         [modifiedMenu.width - 70, modifiedMenu.height - 30],
                    //         [10, modifiedMenu.height]
                    // ]);

                    const mid = {
                        x: dstPoints.reduce((a, b) => a + b.x, 0) / dstPoints.length,
                        y: dstPoints.reduce((a, b) => a + b.y, 0) / dstPoints.length
                    };

                    
                    // low low
                    const topLeft = dstPoints.find(p => p.x < mid.x && p.y < mid.y);
                    // high low
                    const topRight = dstPoints.find(p => p.x > mid.x && p.y < mid.y);
                    // high high
                    const bottomRight = dstPoints.find(p => p.x > mid.x && p.y > mid.y);
                    // low high
                    const bottomLeft = dstPoints.find(p => p.x < mid.x && p.y > mid.y);

                    console.log(dstPoints, [topLeft, topRight, bottomRight, bottomLeft])


                    // p.draw([topLeft, topRight, bottomRight, bottomLeft]);
                    p.draw([[topLeft.x, topLeft.y], [topRight.x, topRight.y], [bottomRight.x, bottomRight.y], [bottomLeft.x, bottomLeft.y]]);

                    // p.draw([
                    //         [30, 30],
                    //         [100 - 50, 50],
                    //         [100 - 70, 100 - 30],
                    //         [10, 100]
                    // ]);


                    // p.draw([
                    //         [30, 30],
                    //         [1000, 50],
                    //         [1000, 1000],
                    //         [10, 1000]
                    // ]);

                    // p.draw([
                    //         [30, 30],
                    //         [1000, 50],
                    //         [1000, 1000],
                    //         [10, 1000]
                    // ]);

                    // p.draw([
                    //         [30, 30],
                    //         [100, 50],
                    //         [100, 100],
                    //         [10, 100]
                    // ]);

                    // p.draw([dstPoints[1], dstPoints[0], dstPoints[3], dstPoints[2]]);
                    // debugger


                    // p.draw([
                    //         [30, 30],
                    //         [arCanvas.width - 50, 50],
                    //         [arCanvas.width - 70, arCanvas.height - 30],
                    //         [10, arCanvas.height]
                    // ]);
                    // debugger

                    // debugger

                    // Apply perspective transformation
                    // arContext.setTransform(
                    //     (dstPoints[1].x - dstPoints[0].x) / (srcPoints[1].x - srcPoints[0].x),
                    //     (dstPoints[2].x - dstPoints[1].x) / (srcPoints[2].x - srcPoints[1].x),
                    //     (dstPoints[0].y - dstPoints[1].y + dstPoints[2].y - dstPoints[3].y) /
                    //     (srcPoints[0].y - srcPoints[1].y + srcPoints[2].y - srcPoints[3].y),
                    //     (dstPoints[0].y - dstPoints[3].y) / (srcPoints[0].y - srcPoints[3].y),
                    //     dstPoints[0].x - srcPoints[0].x * ((dstPoints[1].x - dstPoints[0].x) / (srcPoints[1].x - srcPoints[0].x)),
                    //     dstPoints[0].y - srcPoints[0].y * ((dstPoints[0].y - dstPoints[3].y) / (srcPoints[0].y - srcPoints[3].y))
                    // );


                    // arContext.fillStyle = '#ff0';
                    // // arContext.beginPath();
                    // // arContext.moveTo(paperVertices[0].x * arCanvas.width, paperVertices[0].y * arCanvas.width);
                    // // for (let i = 1; i < paperVertices.length; i++) {
                    // //     arContext.lineTo(paperVertices[i].x * arCanvas.width, paperVertices[i].y * arCanvas.width);
                    // // }
                    // // arContext.closePath();
                    // // arContext.fill();

                    // // arContext.setTransform(1, 0.2, 0.8, 1, 0, 0);
                    // arContext.setTransform(
                    //     (dstPoints[1].x - dstPoints[0].x) / (srcPoints[1].x - srcPoints[0].x),
                    //     (dstPoints[2].x - dstPoints[1].x) / (srcPoints[2].x - srcPoints[1].x),
                    //     (dstPoints[0].y - dstPoints[1].y + dstPoints[2].y - dstPoints[3].y) /
                    //     (srcPoints[0].y - srcPoints[1].y + srcPoints[2].y - srcPoints[3].y),
                    //     (dstPoints[0].y - dstPoints[3].y) / (srcPoints[0].y - srcPoints[3].y),
                    //     dstPoints[0].x - srcPoints[0].x * ((dstPoints[1].x - dstPoints[0].x) / (srcPoints[1].x - srcPoints[0].x)),
                    //     dstPoints[0].y - srcPoints[0].y * ((dstPoints[0].y - dstPoints[3].y) / (srcPoints[0].y - srcPoints[3].y))
                    // );
                    // arContext.fillRect(0, 0, 100, 100);


                    // // Draw the transformed image
                    // // arContext.drawImage(modifiedMenu, 0, 0);

                    
                    // arContext.restore();
                    // // debugger

                }
            } else {
                paperVertices = undefined;
            }
        }


        function waitForOpenCV(callback) {
            if (typeof cv !== 'undefined' && typeof cv.Mat === 'function') {
                callback();
            } else {
                setTimeout(function() {
                    waitForOpenCV(callback);
                }, 100);
            }
        }

        const webcamScan = () => {
            requestAnimationFrame(webcamScan)
            // render webcam image to canvas
            const webcam = document.getElementById('webcam');
            const webcamCanvas = document.createElement('canvas');
            webcamCanvas.width = webcam.videoWidth;
            webcamCanvas.height = webcam.videoHeight;
            const webcamCtx = webcamCanvas.getContext('2d');
            webcamCtx.drawImage(webcam, 0, 0, webcamCanvas.width, webcamCanvas.height);

            // const targetWidth = 1000;
            // const scale = targetWidth / webcam.videoWidth;
            // webcamCanvas.width = targetWidth;
            // webcamCanvas.height = webcam.videoHeight * scale;
            // const webcamCtx = webcamCanvas.getContext('2d');
            // webcamCtx.drawImage(webcam, 0, 0, webcamCanvas.width, webcamCanvas.height);


            img = webcamCanvas;
            scan();
        }

        waitForOpenCV(() => {

            // img.src = image.src;

            // Get the video element
            // const video = document.getElementById('webcam');

            // // const button = document.createElement('button');
            // // button.onclick = () => {
            // // Check if the browser supports getUserMedia
            // if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            //     // Request access to the webcam
            //     navigator.mediaDevices.getUserMedia({ video: true })
            //         .then(function(stream) {
            //             // Assign the stream to the video element's srcObject
            //             video.srcObject = stream;
            //         })
            //         .catch(function(error) {
            //             console.error("Error accessing the webcam: ", error);
            //         });
            // } else {
            //     console.error("getUserMedia not supported by this browser.");
            // }

            webcamScan();
            // }
            // button.textContent = 'webcam';
            // document.body.append(button);

            
        });
    </script>
</body>
</html>
