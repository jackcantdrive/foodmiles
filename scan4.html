<!DOCTYPE html>
<html>
<head>
    <title>Paper Detection</title>
    <script async src="./opencv-4.5.5.js"></script>
    <!-- <script async src="https://docs.opencv.org/4.5.5/opencv.js"></script> -->
    <style>
        #arCanvas {
            height: 30vh;
        }
    </style>
</head>
<body>
    <h1>Paper Detection</h1>
    <input type="file" id="fileInput" accept="image/*">

    <img id='image' src="IMG_8409-2-copy.jpg"/>
    <!-- <video id="webcam" width="640" height="480" autoplay></video> -->
    <video id="webcam" src='IMG_8416.mp4' controls autoplay muted></video>

    <canvas id="canvasOutput"></canvas>
    <canvas id="arCanvas"></canvas>

    <script>
        let img = new Image();
        img.onload = function () {
            scan();
        }

        let prevFrameVertices = undefined;
        let paperDecay = 0;

        const scan = () => {
            let canvas = document.createElement('canvas');
            let context = canvas.getContext('2d');
            // canvas.width = img.width;
            // canvas.height = img.height;
            // context.drawImage(img, 0, 0);

            const max_width = 100;
            const width = Math.min(max_width, img.width);
            const scale = img.width / width;
            canvas.width = width;
            canvas.height = Math.floor(img.height / scale);
            context.drawImage(img, 0, 0, canvas.width, canvas.height);


            let src = cv.imread(canvas);
            let dst = new cv.Mat();
            const st = performance.now();
            // Convert to grayscale
            cv.cvtColor(src, src, cv.COLOR_RGBA2GRAY, 0);
            // Gaussian blur
            cv.GaussianBlur(src, src, new cv.Size(15, 15), 0, 0, cv.BORDER_DEFAULT);
            // Canny edge detection
            // cv.Canny(src, dst, 75, 200);
            cv.Canny(src, dst, 10, 14);

            // Find contours
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            cv.findContours(dst, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
            // cv.findContours(dst, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_NONE);

            // // Find the largest contour, assuming it's the paper
            // let largestContour = contours.get(0);
            // for (let i = 1; i < contours.size(); ++i) {
            //     if (cv.contourArea(contours.get(i)) > cv.contourArea(largestContour)) {
            //         largestContour = contours.get(i);
            //     }
            // }

            // // Approximate the contour to a polygon
            // let approx = new cv.Mat();
            // cv.approxPolyDP(largestContour, approx, 0.02 * cv.arcLength(largestContour, true), true);

            // // Draw the polygon on the original image
            // let vertices = [];
            // for (let i = 0; i < approx.rows; ++i) {
            //     vertices.push({x: approx.data32S[i*2], y: approx.data32S[i*2 + 1]});
            // }
            // src = cv.imread(canvas);
            // for (let i = 0; i < vertices.length; i++) {
            //     let pt1 = new cv.Point(vertices[i].x, vertices[i].y);
            //     let pt2 = new cv.Point(vertices[(i + 1) % vertices.length].x, vertices[(i + 1) % vertices.length].y);
            //     cv.line(src, pt1, pt2, [255, 0, 0, 255], 4);
            //     // cv.line(src, pt1, pt2, [0, 255, 255, 255], 4);
            //     debugger
            // }

            const contoursByArea = [];
            for (let i = 0; i < contours.size(); ++i) {
                contoursByArea.push({contour: contours.get(i), area: cv.contourArea(contours.get(i))});
            }
            contoursByArea.sort((a, b) => b.area - a.area);

            // Find the largest contour, assuming it's the paper
            const largestContour = contoursByArea[0].contour;
            src = cv.imread(canvas);

            // debugger;
            for (let i = 0; i < contoursByArea.length && i < 4; i++) {
                const contour = contoursByArea[i].contour;
                // console.log(cv.contourArea(contour));
                // Approximate the contour to a polygon
                let approx = new cv.Mat();
                cv.approxPolyDP(contour, approx, 0.02 * cv.arcLength(contour, true), true);

                // Draw the polygon on the original image
                let vertices = [];
                for (let i = 0; i < approx.rows; ++i) {
                    vertices.push({x: approx.data32S[i*2], y: approx.data32S[i*2 + 1]});
                }

                // let color;
                // if (i === 0) {
                //     color = [255, 0, 0, 255];
                // } else {
                //     // color = [0, 0, 255, 255];
                //     color = [0, contoursByArea[i].area * 40, 255, 255];
                // }
                let color = [0, contoursByArea[i].area * 40, 255, 255];

                if (vertices.length !== 4 || contoursByArea[i].area < 3) continue;


                // src = cv.imread(canvas);
                for (let i = 0; i < vertices.length; i++) {
                    let pt1 = new cv.Point(vertices[i].x, vertices[i].y);
                    let pt2 = new cv.Point(vertices[(i + 1) % vertices.length].x, vertices[(i + 1) % vertices.length].y);
                    // cv.line(src, pt1, pt2, [0, 0, 255, 255], 4);
                    cv.line(src, pt1, pt2, color, 4);
                }

                if (i === 0) {
                    // console.log(vertices)

                    if (prevFrameVertices) {
                        const prevFrameVerticesSorted = prevFrameVertices.sort((a, b) => a.x - b.x);
                        const verticesSorted = vertices.sort((a, b) => a.x - b.x);

                        const topLeft = verticesSorted[0];
                        const topRight = verticesSorted[1];
                        const bottomRight = verticesSorted[2];
                        const bottomLeft = verticesSorted[3];

                        const topLeftPrev = prevFrameVerticesSorted[0];
                        const topRightPrev = prevFrameVerticesSorted[1];
                        const bottomRightPrev = prevFrameVerticesSorted[2];
                        const bottomLeftPrev = prevFrameVerticesSorted[3];

                        const topLeftDiff = Math.abs(topLeft.x - topLeftPrev.x) + Math.abs(topLeft.y - topLeftPrev.y);
                        const topRightDiff = Math.abs(topRight.x - topRightPrev.x) + Math.abs(topRight.y - topRightPrev.y);
                        const bottomRightDiff = Math.abs(bottomRight.x - bottomRightPrev.x) + Math.abs(bottomRight.y - bottomRightPrev.y);
                        const bottomLeftDiff = Math.abs(bottomLeft.x - bottomLeftPrev.x) + Math.abs(bottomLeft.y - bottomLeftPrev.y);

                        const diffThreshold = max_width/10;
                        if (topLeftDiff < diffThreshold && topRightDiff < diffThreshold && bottomRightDiff < diffThreshold && bottomLeftDiff < diffThreshold) {
                            // console.log('Paper detected');
                            paperDecay += 0.3;
                        }
                    }

                    prevFrameVertices = vertices;
                }

                contour.delete();
                approx.delete();
            }

            cv.imshow('canvasOutput', src);

            updateARCanvas();

            // Clean up
            src.delete();
            dst.delete();
            contours.delete();
            hierarchy.delete();
            // largestContour.delete();
            // approx.delete();
            // console.log(performance.now() - st);
        };
        // img.src = event.target.result;

        let updateARCanvasLastCalled = 0;
        const updateARCanvas = () => {

            // paperDecay *= 0.5**(1/60);

            const now = performance.now();
            const delta = now - updateARCanvasLastCalled;
            paperDecay -= delta / 1000;
            paperDecay *= 0.5**(delta / 1000);
            paperDecay = Math.max(0, paperDecay);
            updateARCanvasLastCalled = now;

            console.log(paperDecay);
            const arCanvas = document.getElementById('arCanvas');
            const arContext = arCanvas.getContext('2d');
            arCanvas.width = webcam.videoWidth;
            arCanvas.height = webcam.videoHeight;
            arContext.drawImage(webcam, 0, 0, arCanvas.width, arCanvas.height);

            if (paperDecay > 0) {
                // arContext.fillStyle = 'rgba(0, 255, 0, 0.5)';
                arContext.fillStyle = `rgba(0, 255, 0, ${Math.min(0.5, paperDecay/10)})`;
                arContext.fillRect(0, 0, arCanvas.width, arCanvas.height);
            }
        }


        function waitForOpenCV(callback) {
            if (typeof cv !== 'undefined' && typeof cv.Mat === 'function') {
                callback();
            } else {
                setTimeout(function() {
                    waitForOpenCV(callback);
                }, 100);
            }
        }

        const webcamScan = () => {
            requestAnimationFrame(webcamScan)
            // render webcam image to canvas
            const webcam = document.getElementById('webcam');
            const webcamCanvas = document.createElement('canvas');
            webcamCanvas.width = webcam.videoWidth;
            webcamCanvas.height = webcam.videoHeight;
            const webcamCtx = webcamCanvas.getContext('2d');
            webcamCtx.drawImage(webcam, 0, 0, webcamCanvas.width, webcamCanvas.height);

            // const targetWidth = 1000;
            // const scale = targetWidth / webcam.videoWidth;
            // webcamCanvas.width = targetWidth;
            // webcamCanvas.height = webcam.videoHeight * scale;
            // const webcamCtx = webcamCanvas.getContext('2d');
            // webcamCtx.drawImage(webcam, 0, 0, webcamCanvas.width, webcamCanvas.height);


            img = webcamCanvas;
            scan();
        }

        waitForOpenCV(() => {

            // img.src = image.src;

            // Get the video element
            // const video = document.getElementById('webcam');

            // // const button = document.createElement('button');
            // // button.onclick = () => {
            // // Check if the browser supports getUserMedia
            // if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
            //     // Request access to the webcam
            //     navigator.mediaDevices.getUserMedia({ video: true })
            //         .then(function(stream) {
            //             // Assign the stream to the video element's srcObject
            //             video.srcObject = stream;
            //         })
            //         .catch(function(error) {
            //             console.error("Error accessing the webcam: ", error);
            //         });
            // } else {
            //     console.error("getUserMedia not supported by this browser.");
            // }

            webcamScan();
            // }
            // button.textContent = 'webcam';
            // document.body.append(button);

            
        });
    </script>
</body>
</html>
